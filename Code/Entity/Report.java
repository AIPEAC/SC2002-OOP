package Entity;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map.Entry;
import java.io.File;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Represents a comprehensive report of internship opportunities.
 * Generated by career center staff to analyze internship data including statistics
 * by level, major, company, visibility, and slot availability.
 * Reports can be filtered and saved to CSV files for record-keeping.
 * 
 * @author Allen
 * @version 1.0
 */
public class Report {
    /** Unique index/ID for this report */
    private int reportIndex;
    
    /** List of internship opportunities included in this report */
    private List<InternshipOpportunity> internshipOpportunities;
    
    /** Whether this report has filters applied */
    private boolean filtered;
    
    /** Map of applied filters (e.g., status, major, level) */
    private Map<String, List<String>> appliedFilters;
    
    /** Total number of internships in this report */
    private int numOfInternships=0;

    /** Number of Advanced level internships */
    private int numOfAdvancedInternships=0;
    
    /** Number of Intermediate level internships */
    private int numOfIntermediateInternships=0;
    
    /** Number of Basic level internships */
    private int numOfBasicInternships=0;

    /** Number of visible internships (visibility toggled on) */
    private int numOfVisibleInternships=0;
    
    /** Number of internships with all slots filled */
    private int numOfFullInternships=0;
    
    /** Total number of slots across all internships */
    private int numOfTotalSlots=0;
    
    /** Map of majors to number of internships for each major */
    private Map<String,Integer> majorsAndInternship=new HashMap<String,Integer>();
    
    /** Map of companies to their number of internships */
    private Map<String,Integer> companyAndTheirNumOfInternships=new HashMap<String,Integer>();

    /**
     * Constructs a Report without applied filters.
     * 
     * @param reportIndex The unique index for this report
     * @param internshipOpportunities The list of internship opportunities
     * @param filtered Whether the report is filtered
     */
    public Report(int reportIndex,List<InternshipOpportunity> internshipOpportunities,boolean filtered) {
        this.reportIndex = reportIndex;
        this.internshipOpportunities = internshipOpportunities;
        this.filtered=filtered;
        this.appliedFilters = null;
    }
    
    /**
     * Constructs a Report with applied filters.
     * 
     * @param reportIndex The unique index for this report
     * @param internshipOpportunities The list of internship opportunities
     * @param filtered Whether the report is filtered
     * @param appliedFilters The map of applied filters
     */
    public Report(int reportIndex,List<InternshipOpportunity> internshipOpportunities,boolean filtered, Map<String, List<String>> appliedFilters) {
        this.reportIndex = reportIndex;
        this.internshipOpportunities = internshipOpportunities;
        this.filtered=filtered;
        this.appliedFilters = appliedFilters;
    }
    
    /**
     * Build the formatted report lines instead of printing directly.
     * 
     * @return a list of formatted report lines
     */
    public List<String> formatOutput(){
        List<String> lines = new ArrayList<>();
        if (internshipOpportunities == null || internshipOpportunities.size()==0){
            if (!filtered) lines.add("No internship opportunities found.");
            else lines.add("No internship opportunities found after filtering, try another filter.");
            return lines;
        }
        statistifyTheNumbers(internshipOpportunities);
        printStatistics(lines);
        return lines;
    }

    /**
     * Save the current report to local markdown file and return the path.
     * 
     * @return the file path where the report was saved
     * @throws IOException if an I/O error occurs
     */
    public String saveToLocal() throws IOException {
        if (internshipOpportunities==null || internshipOpportunities.size()==0){
            throw new IllegalStateException("No internships to save in report.");
        }
        statistifyTheNumbers(internshipOpportunities);
        String md = buildMarkdownReport();
        File dir = new File("Output_report");
        if (!dir.exists()){
            dir.mkdirs();
        }
        String filename = String.format("Report%04d.md", reportIndex);
        File out = new File(dir, filename);
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(out))){
            bw.write(md);
            return out.getPath();
        }
    }
    
    /**
     * Calculates and sets the statistics for the report.
     * 
     * @param internshipOpportunities The list of internship opportunities to analyze
     */
    private void statistifyTheNumbers(List<InternshipOpportunity> internshipOpportunities){
        // Reset and calculate statistics (safe to call multiple times)
        numOfInternships=0;

        numOfAdvancedInternships=0;
        numOfIntermediateInternships=0;
        numOfBasicInternships=0;

        numOfVisibleInternships=0;
        numOfFullInternships=0;
        numOfTotalSlots=0;

        majorsAndInternship.clear();
        companyAndTheirNumOfInternships.clear();

        //calculate statistics
        numOfInternships=internshipOpportunities.size();

        //calculate number of internships by level and visibility/fullness
        for (int i=0;i<internshipOpportunities.size();i++){
            List<Object> details=internshipOpportunities.get(i).getDetailsForReport();

            //numbers for each level
            if ((details.get(1)).equals("Advanced")){
                numOfAdvancedInternships++;
            }else if((details.get(1)).equals("Intermediate")){
                numOfIntermediateInternships++;
            }else if((details.get(1)).equals("Basic")){
                numOfBasicInternships++;
            }else{
                throw new IllegalStateException("Error in internship level, check the entity code for InternshipOpportunity.");
            }
            
            //numbers for visibable internships
            if ((boolean)details.get(7)){
                numOfVisibleInternships++;
            }

            //numbers for full internships
            if ((boolean)details.get(8)){
                numOfFullInternships++;
            }

            //number of total slots
            numOfTotalSlots+= (int) details.get(6);

            //majors and their number of internships
            @SuppressWarnings("unchecked")
            List<String> preferredMajors=(List<String>) details.get(2);
            for (int j=0;j<preferredMajors.size();j++){
                String major=preferredMajors.get(j);
                if (majorsAndInternship.containsKey(major)){
                    majorsAndInternship.put(major,majorsAndInternship.get(major)+1);
                }else{
                    majorsAndInternship.put(major,1);
                }
            }
            //company and their number of internships
            String companyName=(String) details.get(5);
            if (companyAndTheirNumOfInternships.containsKey(companyName)){
                companyAndTheirNumOfInternships.put(companyName,companyAndTheirNumOfInternships.get(companyName)+1);
            }else{
                companyAndTheirNumOfInternships.put(companyName,1);
            }
        }
    }

    /**
     * Appends the statistics to the list of lines.
     * 
     * @param lines The list to append the statistics to
     */
    private void printStatistics(List<String> lines){
        // Punchy header
        lines.add("========================================");
        lines.add("üî• PREVALENT INTERNSHIP REPORT - #"+reportIndex);
        lines.add("(Showing "+numOfInternships+" internships"+(filtered?" after filters":"")+")");
        lines.add("========================================");

        int maxForBars = Math.max(1, numOfInternships);
        lines.add("Levels:");
        appendLabeledCount(lines, "Advanced", numOfAdvancedInternships, maxForBars);
        appendLabeledCount(lines, "Intermediate", numOfIntermediateInternships, maxForBars);
        appendLabeledCount(lines, "Basic", numOfBasicInternships, maxForBars);
        lines.add("");

        lines.add("Visibility & Fullness:");
        appendLabeledCount(lines, "Visible", numOfVisibleInternships, maxForBars);
        appendLabeledCount(lines, "Full", numOfFullInternships, maxForBars);
        lines.add("");

        lines.add("Total slots across all internships: "+numOfTotalSlots);
        lines.add("");

        lines.add("Top majors by number of internships:");
        List<Entry<String,Integer>> majorsSorted = sortMapByValueDesc(majorsAndInternship);
        if (majorsSorted.isEmpty()){
            lines.add(" (none)");
        } else {
            int topN = Math.min(10, majorsSorted.size());
            int maxMajorCount = majorsSorted.get(0).getValue();
            for (int i=0;i<topN;i++){
                Entry<String,Integer> e = majorsSorted.get(i);
                appendLabeledCount(lines, e.getKey(), e.getValue(), Math.max(1, maxMajorCount));
            }
            if (majorsSorted.size()>topN){
                lines.add("...and "+(majorsSorted.size()-topN)+" more majors.");
            }
        }
        lines.add("");

        lines.add("Top companies by number of internships:");
        List<Entry<String,Integer>> companiesSorted = sortMapByValueDesc(companyAndTheirNumOfInternships);
        if (companiesSorted.isEmpty()){
            lines.add(" (none)");
        } else {
            int topCompanies = Math.min(5, companiesSorted.size());
            int maxCompanyCount = companiesSorted.get(0).getValue();
            for (int i=0;i<topCompanies;i++){
                Entry<String,Integer> e = companiesSorted.get(i);
                lines.add((i+1)+". "+tableRowText(e.getKey(), e.getValue(), Math.max(1, maxCompanyCount), 20));
            }
            if (companiesSorted.size()>topCompanies){
                lines.add("...and "+(companiesSorted.size()-topCompanies)+" more companies.");
            }
        }

        lines.add("========================================");
    }

    // Helper: print a label, raw count, percentage and a small ASCII bar
    /**
     * Appends a labeled count with percentage and bar to the lines.
     * 
     * @param lines The list to append to
     * @param label The label for the count
     * @param count The count value
     * @param maxForBars The maximum value for the bar
     */
    private void appendLabeledCount(List<String> lines, String label, int count, int maxForBars){
        double pct = (numOfInternships>0)?(count*100.0/numOfInternships):0.0;
        String pctStr = String.format("%.1f", pct);
        String bar = makeBar(count, maxForBars, 30);
        lines.add(String.format("%-20s %4d  (%5s%%) %s", label, count, pctStr, bar));
    }
    /**
     * Creates an ASCII bar for visualization.
     * 
     * @param value The value to represent
     * @param max The maximum value
     * @param width The width of the bar
     * @return The ASCII bar string
     */
    private String makeBar(int value, int max, int width){
        if (max<=0) max=1;
        int filled = (int) Math.round((double)value / max * width);
        StringBuilder sb = new StringBuilder();
        for (int i=0;i<filled;i++) sb.append('‚ñà');
        for (int i=filled;i<width;i++) sb.append(' ');
        return "|"+sb.toString()+"|";
    }
    /**
     * Sorts a map by value in descending order.
     * 
     * @param map The map to sort
     * @return The sorted list of entries
     */
    private List<Entry<String,Integer>> sortMapByValueDesc(Map<String,Integer> map){
        List<Entry<String,Integer>> list = new ArrayList<>(map.entrySet());
        Collections.sort(list, new Comparator<Entry<String,Integer>>(){
            public int compare(Entry<String,Integer> a, Entry<String,Integer> b){
                return b.getValue().compareTo(a.getValue());
            }
        });
        return list;
    }


    // Build a Markdown-formatted report string
    /**
     * Builds the report in Markdown format.
     * 
     * @return The Markdown string
     */
    private String buildMarkdownReport(){
        StringBuilder sb = new StringBuilder();
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        sb.append("# üî• PREVALENT INTERNSHIP REPORT - #"+reportIndex+"\n\n");
        sb.append("_Generated: "+LocalDateTime.now().format(dtf)+"_\n\n");
        
        // Add filter information if this is a filtered report
        if (filtered && appliedFilters != null && !appliedFilters.isEmpty()) {
            sb.append("## üîç Applied Filters\n\n");
            
            // Company Names
            if (appliedFilters.containsKey("CompanyName") && !appliedFilters.get("CompanyName").isEmpty()) {
                sb.append("**Companies:** ");
                sb.append(String.join(", ", appliedFilters.get("CompanyName")));
                sb.append("\n\n");
            }
            
            // Levels
            if (appliedFilters.containsKey("Level") && !appliedFilters.get("Level").isEmpty()) {
                sb.append("**Levels:** ");
                sb.append(String.join(", ", appliedFilters.get("Level")));
                sb.append("\n\n");
            }
            
            // Majors
            if (appliedFilters.containsKey("Major") && !appliedFilters.get("Major").isEmpty()) {
                sb.append("**Majors:** ");
                sb.append(String.join(", ", appliedFilters.get("Major")));
                sb.append("\n\n");
            }
            
            // Start Date
            if (appliedFilters.containsKey("StartDate") && !appliedFilters.get("StartDate").isEmpty()) {
                sb.append("**Start Date (from):** ");
                sb.append(appliedFilters.get("StartDate").get(0));
                sb.append("\n\n");
            }
            
            sb.append("---\n\n");
        }
        
        sb.append("**Total internships:** "+numOfInternships+(filtered?" (filtered)":"")+"\n\n");

        int maxForBars = Math.max(1, numOfInternships);

        sb.append("## Levels\n\n");
        sb.append("| Level | Count | % | Bar |\n");
        sb.append("|---|---:|---:|---|\n");
        sb.append(tableRowMd("Advanced", numOfAdvancedInternships, maxForBars, 20));
        sb.append(tableRowMd("Intermediate", numOfIntermediateInternships, maxForBars, 20));
        sb.append(tableRowMd("Basic", numOfBasicInternships, maxForBars, 20));
        sb.append("\n");

        sb.append("## Visibility & Fullness\n\n");
        sb.append("| Metric | Count | % | Bar |\n");
        sb.append("|---|---:|---:|---|\n");
        sb.append(tableRowMd("Visible", numOfVisibleInternships, maxForBars, 20));
        sb.append(tableRowMd("Full", numOfFullInternships, maxForBars, 20));
        sb.append("\n");

        sb.append("**Total slots across all internships:** "+numOfTotalSlots+"\n\n");

        sb.append("## Top Majors\n\n");
        List<Entry<String,Integer>> majorsSorted = sortMapByValueDesc(majorsAndInternship);
        if (majorsSorted.isEmpty()){
            sb.append("(none)\n\n");
        } else {
            sb.append("| Major | Count | % | Bar |\n");
            sb.append("|---|---:|---:|---|\n");
            int topN = Math.min(10, majorsSorted.size());
            int maxMajor = majorsSorted.get(0).getValue();
            for (int i=0;i<topN;i++){
                Entry<String,Integer> e = majorsSorted.get(i);
                sb.append(tableRowMd(e.getKey(), e.getValue(), Math.max(1, maxMajor), 20));
            }
            if (majorsSorted.size()>topN) sb.append("...and "+(majorsSorted.size()-topN)+" more majors.\n\n");
            else sb.append("\n");
        }

        sb.append("## Top Companies\n\n");
        List<Entry<String,Integer>> companiesSorted = sortMapByValueDesc(companyAndTheirNumOfInternships);
        if (companiesSorted.isEmpty()){
            sb.append("(none)\n\n");
        } else {
            sb.append("| Company | Count | % | Bar |\n");
            sb.append("|---|---:|---:|---|\n");
            int topC = Math.min(5, companiesSorted.size());
            int maxComp = companiesSorted.get(0).getValue();
            for (int i=0;i<topC;i++){
                Entry<String,Integer> e = companiesSorted.get(i);
                sb.append(tableRowMd((i+1)+". "+e.getKey(), e.getValue(), Math.max(1, maxComp), 20));
            }
            if (companiesSorted.size()>topC) sb.append("...and "+(companiesSorted.size()-topC)+" more companies.\n\n");
            else sb.append("\n");
        }

        sb.append("---\n\n");
        sb.append("*Generated by the internship reporting system.*\n");
        return sb.toString();
    }
    /**
     * Creates a Markdown table row.
     * 
     * @param label The label
     * @param count The count
     * @param maxForBars The max for bars
     * @param width The width
     * @return The table row string
     */
    private String tableRowMd(String label, int count, int maxForBars, int width){
        double pct = (numOfInternships>0)?(count*100.0/numOfInternships):0.0;
        String pctStr = String.format("%.1f", pct);
        String bar = makeBar(count, maxForBars, width);
        return String.format("| %s | %d | %s%% | `%s` |\n", escapeMd(label), count, pctStr, bar);
    }
    /**
     * Creates a text table row.
     * 
     * @param label The label
     * @param count The count
     * @param maxForBars The max for bars
     * @param width The width
     * @return The table row string
     */
    private String tableRowText(String label, int count, int maxForBars, int width){
        double pct = (numOfInternships>0)?(count*100.0/numOfInternships):0.0;
        String pctStr = String.format("%.1f", pct);
        String bar = makeBar(count, maxForBars, width);
        return String.format("%s | %d | %s%% | %s", label, count, pctStr, bar);
    }
    /**
     * Escapes Markdown special characters.
     * 
     * @param s The string to escape
     * @return The escaped string
     */
    private String escapeMd(String s){
        if (s==null) return "";
        return s.replace("|","\\|");
    }
}

